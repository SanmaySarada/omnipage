---
phase: 05-3d-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - components/three/scene.tsx
  - components/providers.tsx
autonomous: true

must_haves:
  truths:
    - "Single Canvas with View.Port renders at app root"
    - "Canvas is dynamically imported with ssr: false"
    - "No hydration errors occur on page load"
    - "iOS Safari receives conservative gl settings"
  artifacts:
    - path: "components/three/scene.tsx"
      provides: "Scene3D canvas container"
      exports: ["Scene3D"]
      min_lines: 25
    - path: "components/providers.tsx"
      provides: "Updated providers with Scene3D"
      contains: "dynamic"
  key_links:
    - from: "components/providers.tsx"
      to: "components/three/scene.tsx"
      via: "dynamic import with ssr: false"
      pattern: "dynamic.*scene.*ssr.*false"
    - from: "components/three/scene.tsx"
      to: "@react-three/fiber"
      via: "Canvas import"
      pattern: "import.*Canvas.*@react-three/fiber"
    - from: "components/three/scene.tsx"
      to: "@react-three/drei"
      via: "View.Port import"
      pattern: "import.*View.*@react-three/drei"
---

<objective>
Create Scene3D canvas infrastructure with View.Port pattern

Purpose: Establish single persistent Canvas that all 3D viewports will render through
Output: Scene3D component with iOS-safe settings, Providers updated to wrap app with Scene3D
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-3d-infrastructure/05-RESEARCH.md
@components/providers.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Scene3D canvas container</name>
  <files>components/three/scene.tsx</files>
  <action>
Create `components/three/scene.tsx` with the Scene3D component:

```typescript
'use client'

import { Canvas } from '@react-three/fiber'
import { View, Preload } from '@react-three/drei'
import { useRef } from 'react'

interface Scene3DProps {
  children: React.ReactNode
}

export function Scene3D({ children }: Scene3DProps) {
  const containerRef = useRef<HTMLDivElement>(null)

  return (
    <div ref={containerRef} className="relative">
      {children}
      <div className="fixed inset-0 pointer-events-none" style={{ zIndex: 10 }}>
        <Canvas
          eventSource={containerRef}
          eventPrefix="client"
          gl={{
            powerPreference: 'default',
            antialias: false,
          }}
          dpr={[1, 2]}
          fallback={<div className="sr-only">WebGL not supported</div>}
        >
          <View.Port />
          <Preload all />
        </Canvas>
      </div>
    </div>
  )
}
```

IMPORTANT iOS Safari settings (from research):
- `powerPreference: 'default'` (not 'high-performance') - prevents GPU throttling
- `antialias: false` - required for iOS Safari stability, prevents memory crashes
- `dpr={[1, 2]}` - caps at 2x, prevents excessive memory on high-DPI devices

The Canvas is positioned fixed with pointer-events-none so it overlays the entire app but doesn't block interactions. View components inside will re-enable pointer-events where needed.

View.Port is the render target - all View components in the tree will render their 3D content here.

Preload all ensures 3D assets are preloaded for smoother experience.
  </action>
  <verify>
File exists at components/three/scene.tsx with:
- 'use client' directive
- Canvas with gl settings (powerPreference, antialias: false)
- View.Port inside Canvas
- Preload component
  </verify>
  <done>Scene3D component exports correctly with iOS-safe Canvas settings</done>
</task>

<task type="auto">
  <name>Task 2: Update Providers with dynamic Scene3D</name>
  <files>components/providers.tsx</files>
  <action>
Update `components/providers.tsx` to include Scene3D with dynamic import:

```typescript
'use client'

import { MotionConfig } from 'motion/react'
import dynamic from 'next/dynamic'

const Scene3D = dynamic(
  () => import('@/components/three/scene').then(mod => mod.Scene3D),
  { ssr: false }
)

export function Providers({ children }: { children: React.ReactNode }) {
  return (
    <MotionConfig reducedMotion="user">
      <Scene3D>
        {children}
      </Scene3D>
    </MotionConfig>
  )
}
```

WHY dynamic import with ssr: false:
- Canvas uses browser-only WebGL APIs
- Server rendering Canvas causes hydration mismatch errors
- next/dynamic handles this correctly, React.lazy does not

Scene3D wraps children so the Canvas is mounted once at app root and persists across all routes.
  </action>
  <verify>
1. `npm run dev` starts without errors
2. Open browser DevTools console - no hydration errors
3. Browser WebGL context is created (check via about:gpu or canvas inspector)
  </verify>
  <done>Providers wraps app with dynamically imported Scene3D, no hydration errors</done>
</task>

</tasks>

<verification>
1. `npm run dev` starts without console errors
2. No "hydration failed" or "text content does not match" errors in browser console
3. DevTools Elements shows fixed Canvas element in DOM
4. WebGL context created (visible in browser dev tools or three.js stats)
</verification>

<success_criteria>
- Scene3D component created with iOS-safe Canvas settings
- Providers dynamically imports Scene3D with ssr: false
- App loads without hydration errors
- Canvas with View.Port is mounted and ready for View components
</success_criteria>

<output>
After completion, create `.planning/phases/05-3d-infrastructure/05-02-SUMMARY.md`
</output>
